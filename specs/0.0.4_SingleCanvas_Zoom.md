# @maplat/triangulation 0.0.4 

## 主要な開発目的と、短期的な目標
プロジェクトの構造は、二重プロジェクト構造になっている。
ルートにproject.jsonがあって、その下のuiフォルダにもproject.jsonが存在する

ルートプロジェクトの主目的は、以下のライブラリを完成させることである
* 2平面に存在する対応点（最高数千点オーダー）に対し、
  * 両平面でトポロジーエラー（線交差、三角形の裏返り）を起こさない三角網生成ロジックを完成させる
  * エラーが発生した場合は、検知し、繋ぎ変えや補助点追加でエラーを解消する
  * 論理的に絶対エラーが解消できない対応点構造の場合は、それを検知し、解消できない理由を説明する

しかし、上記を完遂するには、豊富なエッジケースのテストデータ生成が必須であるが、ツールなしにそれを生成することは難しい
そこでまず短期的にはuiフォルダの下で、主目的ライブラリのテストケースを自動生成、ライブラリが動いているかを確認するテストUI、かつインタラクティブに点の位置などを編集して、エラーのエッジケースを生成するUIを作成するUIアプリを作成することを目的としている

## 0.0.3までで実装した機能

### 開発項目1. テストデータ生成UIの作成

- 2つの非相似平面を表示するCanvas（平面A, 平面B）を実装済み。
- 点群はフォーム入力値に応じてリアクティブに生成、JSON形式でTextAreaに表示。
- 点群のJSONデータとCanvas表示が双方向に即時連携されている。
- 点群へのアフィン変換（ランダムなスケール、平行移動、30度刻みの回転、ガウス揺らぎ）を実装。
- Svelte 5のRunes API ($state, $effect, $props) を使用し、リアクティブな状態管理を行っている。
- Canvas表示範囲の正規化を実装済（アスペクト比維持、マージン付きで常に全点表示）。
- 点クリックによる選択状態の表示、ドラッグ移動による点位置の更新を実装済み。
- 三角網表示のオンオフトグルを実装、表示時には点移動が無効化される。
- 三角網表示時には、平面Aから生成した三角網を両平面に表示。

## 0.0.4で実装する機能

### Canvas処理の単独コンポーネント化

- 現在、CanvasPair.svelteは、2つのCanvasを内部に含むSvelteのUI部品化されている
  しかし、単独のCanvasで、
  1. 与えられた点群JSONに対し、点を表示し、それに対し操作が加えられれば、加えられた操作による新しい座標を返す
  2. 与えられた点群の範囲で、表示範囲を正規化し表示する
  3. 三角網のJSONが与えられれば、点群の移動機能をオフにし、三角網を表示する
  4. 三角網表示を消す処理が与えられれば、三角網を消し、点群の移動機能を再起動する
  5. 点群の点がクリックされれば、その点を選択中表示西、その点のインデックスを選択中として返す
  6. 点群のインデックスが与えられれば、その点を選択中として表示を変更する
  7. 点群のインデックスとしてnullを与えると、点群の選択状態をなしにする
  という形で一般化すれば、1つのキャンバスを1コンポーネント化(Canvas.svelteなど)し、そのコンポーネントを並べることでCanvasPair.svelteが定義できる
  片方のキャンバスの点が選ばれたときに、もう一方のキャンバスの対応点が反応する処理も、5.と6.の機能の組み合わせで実現するはずである
  点群や三角網に対しこのような処理を行うUIは再利用性が高いため、1Canvasで部品化しておきたい

### CanvasコンポーネントのZOOM/パン処理対応、あるいはCanvasのOpenLayers化

- 表示範囲の正規化による全体表示はよいが、点数が多くなると細かいところが見にくくなり、状況がつかみにくい
  そこで、正規化による全体表示は新しいデータの初期表示、および各キャンバスに「初期表示に戻す」ボタンを新設してそれが押し下げられた時のみ正規化範囲表示として、それ以外の時はマウスドラッグ、マウスホイールで表示範囲の移動、拡縮を行えるようにしたい
- それにあたり、マウスドラッグ、マウスホイールでのズーム、パン機能をCanvas要素に簡単につけられるならばそれでもよいが、おそらくデバグに苦労すると思われる
- そこでCanvasの代わりに、OpenLayersの最新版を使うことを提案する
  * OpenLayersには、地理座標の他にXY座標で座標系を扱うモードもあるので、その座標系を用いつつ、Canvasへの描画をOpenLayersでのベクトルレイヤーに描画する要素に変更すればそれほど変わらないのではないかと思われる
  * 座標の正規化、表示範囲の導出などのロジックはそのまま使われるはず
  * ズーム、パンなどはOpenLayers自体がその機能をデフォルトで持つ
  * 将来、対応点に両平面で同じ番号のピンなどを立てて、対応点をわかりやすくする処理なども、OpenLayersを用いた方が容易と思われる
- また、OpenLayersで実装した方が、今後の地図サイト要件などでも再利用しやすい
- これらの理由により、Canvasでの実装をOpenLayersに置き換えたい

### 進め方
- まずCanvasPair.svelteの各Canvasを単独Canvas.svelte化して汎用化し、そこでCanvas.svelteの中身をOpenLayersに置き換える
- ここまでで0.0.4とする

## 開発の考慮事項 (重要!!)

### 一般

- 既存の実装、src/topology.ts, src/triangulation.ts, scripts/generateTestData.tsなどで開発済みのロジックは再利用すること
  インタフェースを用意していないなどの理由で再利用可能になっていない場合は、汎用関数化するなどで再利用可能なよう、既存実装を再定義すること
- コードが長くなるのを避けるため、特にUI周りで、Svelteを使って見通しをよくすること
  １つのファイルが何百行にもなって何を行っているのかわからなくならないよう、100行を越えるか越えないかくらいで、コードを分けることを考えること
    - たとえば、Svelteを使ってCanvasへの処理を汎用化 (平面A, Bに関わらず、点群から表示範囲を正規化し表示、点や辺へのインタラクションのみを担当するコンポーネントを開発し、それを2つ並べて平面A、Bに対応、点や辺へのインタラクションへの処理を、コンポーネントの外で実施 => 処理結果をコンポーネントに変換して描画更新、という形が考え得る)
- 表示範囲の正規化に関しては、Canvasの大きさの値に、表示範囲と描画範囲の2つがあることに留意が必要
  width/heightと、clientWidth/clientHeight、両者を齟齬が発生するたびに一致させる処理が必要

### Svelte 5移行に伴う課題と注意点

- Svelte 5の新機能 (Runes API) を用いる際、従来の`writable`ストアや旧リアクティブ文法は使用しない。
- `$state`, `$effect` はグローバルで定義されているため、`import`文でインポートしてはならない。
- 標準DOMイベント (`click`) は従来の`on:click`ではなく、`onclick`に変更されている。
- カスタムイベント (`generate`, `update` など) は従来どおりの`on:generate`、`on:update`を使用する。
- コンポーネントのプロパティ渡しは、`export let`ではなく、Runes APIの`$props()`を使用する。

### デグレード（退行）防止について

- 新機能追加時には、既存機能（特に点群の生成・表示・編集機能、正規化表示機能）への影響を十分に検証すること。
- 機能変更後は必ずJSONデータ連携やCanvas正規化表示、インタラクティブ機能の動作確認を行い、デグレードを防ぐこと。